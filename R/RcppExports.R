# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' askYesNoQuestion
askYesNoQuestion <- function(message) {
    .Call('_remify_askYesNoQuestion', PACKAGE = 'remify', message)
}

#' warningMessage
warningMessage <- function(cond) {
    .Call('_remify_warningMessage', PACKAGE = 'remify', cond)
}

#' errorMessage
errorMessage <- function(cond) {
    .Call('_remify_errorMessage', PACKAGE = 'remify', cond)
}

#' rearrangeDataFrame
#'
#' @param x `data.frame` object to reorder
#' @param index vector with the new order
#'
#' @return data.frame `x` whose columns are rearranged according to `index`
rearrangeDataFrame <- function(x, index) {
    .Call('_remify_rearrangeDataFrame', PACKAGE = 'remify', x, index)
}

#' rearrangeList
#'
#' @param x `'list` object to reorder
#' @param index vector with the new order
#'
#' @return list `x` rearranged according to `index` 
rearrangeList <- function(x, index) {
    .Call('_remify_rearrangeList', PACKAGE = 'remify', x, index)
}

#' getIntereventTime
#'
#' @param time first column of the edgelist (time variable) 
#' @param ordinal 
#'
#' @return list of objects
getIntereventTime <- function(time, origin, ordinal) {
    .Call('_remify_getIntereventTime', PACKAGE = 'remify', time, origin, ordinal)
}

#' getRisksetMatrix (obtain permutations of actors' ids and event types).
#'
#' @param actorID vector of actors' id's.
#' @param typeID vector of types' id's.
#' @param N number of actors in the dataset.
#' @param C number of event types
#' @param direcred are events directed or undirected?
#'
#' @return matrix of possible dyadic events.
#'
getRisksetMatrix <- function(actorID, typeID, N, C, directed) {
    .Call('_remify_getRisksetMatrix', PACKAGE = 'remify', actorID, typeID, N, C, directed)
}

#' getRisksetCube
#'
#' @param risksetMatrix output of getRiskset() function
#' @param N number of actors in the dataset.
#' @param C number of event types
#'
#' @return cube of possible combination [sender,receiver,type]: the cell value is the column index in the rehBinary matrix
#'
getRisksetCube <- function(risksetMatrix, N, C) {
    .Call('_remify_getRisksetCube', PACKAGE = 'remify', risksetMatrix, N, C)
}

#' convertInputREH
#'
#' @param edgelist is the input data frame with information about [time,sender,receiver,type,weight] by row.
#' @param riskset riskset list with old actors sitring names.
#' @param actorsDictionary dictionary of actors names (input string name = integer id)
#' @param typesDicitonary dictionary of event types (input string name = integer id)
#' @param M number of observed relational events
#' @param directed boolean if the network is directed or not
#'
#' @return cube of possible combination [sender,receiver,type]: the cell value is the column index in the rehBinary matrix
#'
convertInputREH <- function(edgelist, riskset, actorsDictionary, typesDictionary, M, directed) {
    .Call('_remify_convertInputREH', PACKAGE = 'remify', edgelist, riskset, actorsDictionary, typesDictionary, M, directed)
}

#' getBinaryREH (a function that returns a utility matrix used in optimization algorithms)
#'
#' @param edgelist edgelist converted according to actorID and typeID
#' @param riskset riskset list converted according to actorID and typeID
#' @param risksetCube arma::cube object [N*N*C] where the cell value returns the column index to use in the outBinaryREH
#' @param M number of observed relational events
#' @param D number of possible dyads (accounting for event types as well)
#'
#' @return utility matrix per row 0 if the event could happen but didn't, 1 if the event happend, -1 if the event couldn't occur
#' 
getBinaryREH <- function(edgelist, riskset, risksetCube, M, D) {
    .Call('_remify_getBinaryREH', PACKAGE = 'remify', edgelist, riskset, risksetCube, M, D)
}

#' rehCpp (a function for preprocessing data)
#'
#' @param edgelist is a dataframe of relational events sorted by time: [time,actor1,actor2,type,weight]
#' @param covariates list of covariates to be provided according to the input structure working with 'remstats'
#' @param add_actors vector of actors not in the network but to be considered in the analysis
#' @param add_types vector of types not in the network but to considered in the analysis
#' @param directed dyadic events directed (TRUE) or undirected (FALSE)
#' @param ordinal TRUE if the only the time order of events is known, FALSE if also the time value is known
#' @param origin time origin value 
#' @param riskset is a list of length equal to the number of events, each object a matrix with unobserved dyads (using actors string names)
#'
#' @return list of objects
#' @export
rehCpp <- function(edgelist, covariates, add_actors, add_types, directed, ordinal, origin, riskset) {
    .Call('_remify_rehCpp', PACKAGE = 'remify', edgelist, covariates, add_actors, add_types, directed, ordinal, origin, riskset)
}

#' tryClone
#'
#' @param N N parameter
#' @param C C parameter
#'
#' @return NumericVector
#'
#' @export
tryClone <- function(N, C) {
    .Call('_remify_tryClone', PACKAGE = 'remify', N, C)
}

