---
title: "Risk set" 
author: ""
package: remify
date: ""
output: 
  rmarkdown::html_document:
    theme: bootstrap
    css: "remify-theme.css"
header-includes:
   - \usepackage{tikz}
   - \usepackage{pgfplots}
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{Define a dynamic risk set}
  %\VignetteEncoding{UTF-8}
---

---

<i> This vignette provides a definition of static and dynamic risk set, explains how a dynamic risk set is supplied to the processing function `remify::reh()`, and it shows how the risk set looks like in the processed `reh` object. </i>

---

Consider the processed `reh` object for the network `randomREHsmall`.

```{r}
library(remify)

# randomREHsmall
data(randomREHsmall) 

# processing the edgelist 
small_edgelist_reh <- reh(edgelist = randomREHsmall$edgelist,
                          actors = randomREHsmall$actors,
                          directed = TRUE, # events are directed
                          ordinal = FALSE, # model with waiting times
                          origin = randomREHsmall$origin,
                          omit_dyad = randomREHsmall$omit_dyad,
                          model = "tie") # tie-oriented modeling            
```
---

# {.tabset .tabset-fade .tabset-pills .tabcontent} 


## Definition of risk set


A relational event history consists of a time-ordered sequence of (directed or undirected) interactions, and for each event, we know its time (or the order) of occurrence, the actors that were involved in the interaction and the type of the interaction (if measured). 
For instance, the first five events of the `randomREHsmall` sequence are reported as follows
```{r, include = TRUE}
randomREHsmall$edgelist[1:5,]
```
where `time`, `actor1`, `actor2` describe each observed event in the sequence (Note that in this example the `type` of events is not annotated).

When modeling a relational event sequence, we have to define per each time point a risk set. The risk set consists of the ensemble of those relational events (dyads) that at each time point were observed or that they were likely to be observed but they didn't occur. The definition of the risk set is an important building block of the likelihood function for both tie-oriented and actor-oriented modeling.

### The _static_ risk set
As a common assumption, the compostion of the risk set is assumed to be the same over time (_static_ risk set), which means that for the whole period of study the risk set is made of the same set of dyads. If the network has _N_ actors and it consists of directed events that can assume a number of _C_ possible event types, then the risk set will be characterized by all the possible directed dyads among _N_ actors, that are _D = N(N-1)C_, or _D = N(N-1)C/2_ in the case of undirected dyads. For instance, in the random network (`randomREHsmall`) dyads are directed, actors are _N = 5_ and event types are _C = 1_, therefore we expect the dimension of the risk set to be _D = 5 * 4 * 1 = 20_. The first five dyads in the static risk set will be

```{r, include = TRUE}
# method dyad.reh(), see more in ?remify::dyad
dyad(reh = small_edgelist_reh, dyadID = c(1:5)) 
```

The ID of the dyads (`dyadID`) corresponds to the order of the dyads used by the functions in <a href='https://github.com/TilburgNetworkGroup/remverse'>`remverse`</a> and it is defined by a two-steps approach:

1. Actors' and types' names are first sorted according to their <div class="hovertip">
 alphanumeric<span class="hovertiptext"><p>The alphanumeric order first follows the order of numbers from 0 to 9, then the alphabetical order of the letters.</p> <p>For instance, given the vector of names `c("user22","0usr","1user","1deer")`, its alphanumeric order will be `c("0usr","1deer","1user","user22)`</p><i></i></span></div> order, that for the random network is
```{r, include = TRUE}
# sorted vector of actors' names
sorted_actors <- sort(randomREHsmall$actors)

# number of actors in the network
N <- length(randomREHsmall$actors)
```

2. dyads are defined by the triple `c(actor1,actor2,type)` that is found by looping first on `actor2`, then `actor1`, and finally `type`. An example of the loops is shown below
```{r, include = TRUE}
# no event type, we set it to an empty string
sorted_types <- c("") 

# C = 1 for 'randomREHsmall'
C <- length(sorted_types) 

# initializing matrix object where to store the dyads with their composition [actor1,actor2,type]
dyad_mat <- matrix(NA, nrow = N*(N-1)*C, ncol = 3)
colnames(dyad_mat) <- c("actor1","actor2","type")
rownames(dyad_mat) <- 1:(N*(N-1)*C)

# initializing position index
d <- 1 

# start three loops
for(type in sorted_types){ # loop over event types, 
  for(actor1 in sorted_actors){ # loop over actor1
    for(actor2 in sorted_actors){ # loop over actor2
      if(actor1!=actor2){ # avoid self-loops
        dyad_mat[d,] <- c(actor1,actor2,type)
        d <- d + 1
      }
    }
  }
}

 # same result as showed above by using the method `dyad()`
dyad_mat[1:5,]

# checking the size of the static risk set that is 20
dim(dyad_mat)[1] 
```
The matrix `dyad_mat` above describes the static risk set and the row indices correspond to the ID of the dyad (`dyadID`). For instance, `dyadID` is used in the output of the processed edgelist, under the column named `"dyad"`

```{r, include = TRUE}
head(small_edgelist_reh$edgelist$dyad)
```
A possible way for visualizing the risk set composition at each time point consists in plotting a grid with actors' names on both axes: referring to the senders (on the y axis) and to the receivers (on the x axis). 

<center>
```{r, echo = FALSE}
library(ggplot2)
N <- length(randomREHsmall$actors)
risk_set <- expand.grid(sort(randomREHsmall$actors),sort(randomREHsmall$actors))
p <- list()
dyad_occurred <- c(11,4,11,11) 
for(m in 1:4){
value <- rep(NA,dim(risk_set)[1])
for(d in 1:length(value)){
    if(risk_set[d,1]!=risk_set[d,2]){
        if(d == dyad_occurred[m]){
            value[d] <- 50
        }
        else{
            value[d] <- -50
        }
    }
    else{
       value[d] <- NA
    }
}
dat <- data.frame(actor1=risk_set[,1],actor2=risk_set[,2],value=value)
p[[m]] <- ggplot(dat, aes(x=actor2, y=actor1, fill=value)) +
    geom_tile(colour="grey20") +
    scale_fill_gradient(low="yellow",high="green",na.value=NA)+
    theme_minimal()+
    theme(legend.position="none",
    axis.text.x = element_text(color="black", size=10, angle=90),
    axis.text.y = element_text(color="black", size=10, angle=0), 
    panel.border = element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())+
    ggtitle(paste("t",m,sep=""))
}
gridExtra::grid.arrange(p[[1]],p[[2]],p[[3]],p[[4]], nrow=2)
```
</center>

In the first four time points, we observe the directed dyad _(Colton,Kayla)_ at time $t_1$, $t_3$ and $t_4$ and the dyad _(Lexy,Colton)_ at time $t_2$. The cell corresponding to the relational event occurred at each time point is colored in green. The rest of the cells are colored in yellow, meaning that those dyadic events could have occurred and they are part of the risk set.

A static risk set in the case of undirected networks will assume a particular grid visualization. The dyads at risk will be on the lower triangular grid, because the actor names `c(actor1,actor2)` describing the dyad in the input edgelist are sorted according to their alphanumeric order before being processed. For instance, the event at $t_2$ `c("Lexy","Colton")`, will be rearranged as `c("Colton","Lexy")`, and the risk set will change as follows

<center>
```{r, echo = FALSE}
library(ggplot2)
N <- length(randomREHsmall$actors)
risk_set <- expand.grid(sort(randomREHsmall$actors),sort(randomREHsmall$actors))
p <- list()
dyad_occurred <- c(NA,NA,16) 
for(m in 3){
value <- rep(NA,dim(risk_set)[1])
for(d in 1:dim(risk_set)[1]){
    if(risk_set[d,1]!=risk_set[d,2]){
        if(d == dyad_occurred[m]){
            value[d] <- 50
        }
        else if(as.character(risk_set[d,1])<as.character(risk_set[d,2])){
            value[d] <- -50
        }
    }
}
dat <- data.frame(actor1=risk_set[,1],actor2=risk_set[,2],value=value)
p[[1]] <- ggplot(dat, aes(x=actor2, y=actor1, fill=value)) +
    geom_tile(colour="grey20") +
    scale_fill_gradient(low="yellow",high="green",na.value=NA)+
    theme_minimal()+
    theme(legend.position="none",
    axis.text.x = element_text(color="black", size=10, angle=90),
    axis.text.y = element_text(color="black", size=10, angle=0), 
    panel.border = element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())+
    ggtitle(paste("t",m,sep=""))
}
p[[1]]
```
</center>

In the case of a static risk set, the information about the risk set is constant over time: all the possible dyads will be colored in yellow and the cell for the occuring dyad at each time point will be green. 

A static risk set assumes that all the possible dyads are always at risk regardless any consideration about the actual possibility of one or more actors to still be able to interact with the other actors at specific time windows. This is a starting point that allows us to introduce a dynamic risk set that is time-varying.

### The _dynamic_ risk set
There are circumstances in which one or more actors cannot physically take part in interactions and this can happen either temporarily or since a starting time point until the end of the study. For instance:

- __Example 1:__ when the relational event network is about in-person interactions (e.g., at the university or at school) and it is measured over days (or even weeks or months). One or more actors may not be present during one or more days, therefore we want to exclude such actors from the risk set for the specific time span in which they were not present. 

- __Example 2:__ when relational events are observed at a conference where multiple sessions or workshops can occur at the same time. In this case, the set of dyads at risk splits down to smaller different risk sets, each one based on the groups of actors participating at a specific session or workshop.

- __Example 3:__ when the relational events are digital interactions and one or more actors cannot interact one another because they do not appear in each other's friends list.

In such and other scenarios, a static risk set would account for relational events that are not feasible and this may even lead to biased estimates of the model parameters. It is possible to account for changes of the risk set over time by defining a dynamic risk set.

A dynamic risk set consists of a time-varying definition of the ensemble of dyads at risk and it is based on reasoned considerations about the study and the type of information collected (as in the examples above).

Consider the first four time points of the small random network and assume this time that actors `"Richard"` and `"Francesca"` didn't join the study until the second day of the study. This means that the risk set for at least the first four time points will have the following composition,

<center>
```{r, echo = FALSE}
library(ggplot2)
N <- length(randomREHsmall$actors)
risk_set <- expand.grid(sort(randomREHsmall$actors),sort(randomREHsmall$actors))
p <- list()
dyad_occurred <- c(11,4,11,11) 
for(m in 1:4){
value <- rep(NA,dim(risk_set)[1])
for(d in 1:length(value)){
    if(risk_set[d,1]!=risk_set[d,2]){
        if(d == dyad_occurred[m]){
            value[d] <- 50
        }
        else{
            value[d] <- -50
        }
        if(risk_set[d,1] %in% c("Richard","Francesca") | risk_set[d,2] %in% c("Richard","Francesca")){
          value[d] <- NA
        }
    }
    else{
       value[d] <- NA
    }
}
dat <- data.frame(actor1=risk_set[,1],actor2=risk_set[,2],value=value)
p[[m]] <- ggplot(dat, aes(x=actor2, y=actor1, fill=value)) +
    geom_tile(colour="grey20") +
    scale_fill_gradient(low="yellow",high="green",na.value=NA)+
    theme_minimal()+
    theme(legend.position="none",
    axis.text.x = element_text(color="black", size=10, angle=90),
    axis.text.y = element_text(color="black", size=10, angle=0), 
    panel.border = element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())+
    ggtitle(paste("t",m,sep=""))
}
gridExtra::grid.arrange(p[[1]],p[[2]],p[[3]],p[[4]], nrow=2)
```
</center>

where the cells defining the dyads where `"Richard"` and `"Francesca"` are the sender (actor1) or receiver (actor2) are excluded from the risk set (cells are now in white). The risk set is now made of only those dyads in which `"Colton"`, `"Kayla"` and `"Lexy"`are either the sender or the receiver of the interaction (cells in yellow).

Finally, a dynamic risk set can be defined also for undirected networks and the grid visualization will focus on the lower triangular grid, because the actor names `c(actor1,actor2)` describing the dyad in the input edgelist are sorted according to their alphanumeric order before being processed. For instance, the event at $t_2$ `c("Lexy","Colton")`, will be rearranged as `c("Colton","Lexy")`, thus the risk set will change as below

<center>
```{r, echo = FALSE}
library(ggplot2)
N <- length(randomREHsmall$actors)
risk_set <- expand.grid(sort(randomREHsmall$actors),sort(randomREHsmall$actors))
p <- list()
dyad_occurred <- c(NA,NA,16) 
for(m in 3){
value <- rep(NA,dim(risk_set)[1])
for(d in 1:dim(risk_set)[1]){
    if(risk_set[d,1]!=risk_set[d,2]){
        if(d == dyad_occurred[m]){
            value[d] <- 50
        }
        else if(as.character(risk_set[d,1])<as.character(risk_set[d,2])){
            value[d] <- -50
        }
        if(risk_set[d,1] %in% c("Richard","Francesca") | risk_set[d,2] %in% c("Richard","Francesca")){
          value[d] <- NA
        }
    }
}
dat <- data.frame(actor1=risk_set[,1],actor2=risk_set[,2],value=value)
p[[1]] <- ggplot(dat, aes(x=actor2, y=actor1, fill=value)) +
    geom_tile(colour="grey20") +
    scale_fill_gradient(low="yellow",high="green",na.value=NA)+
    theme_minimal()+
    theme(legend.position="none",
    axis.text.x = element_text(color="black", size=10, angle=90),
    axis.text.y = element_text(color="black", size=10, angle=0), 
    panel.border = element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank())+
    ggtitle(paste("t",m,sep=""))
}
p[[1]]
```
</center>

## Specify a dynamic risk set in reh()

 - _remify::reh_ has an input argument (<i>omit_dyad</i>) that allows the user to define a dynamic risk set and remove specific dyads from one or more time points
 - explain the input omit_dyad, its structure and example from the _randomREH_ data 
 - plot a figure where the intervals specified via <i>omit_dyad</i> are plotted one over the other

#### <b><tt>omit_dyad</tt></b>
This argument is useful when certain dyads must be removed from the risk set in specific time windows (e.g. an actor drops out of the network, specific groups of actors cannot interact anymore starting from some time point). Therefore, the processing of such information makes the risk set suit better to the real data.
`omit_dyad` consists of a list of lists. Each list refers to one risk set modification and must have two objects: a `data.frame` called `dyad`, where dyads to be remove are specified by row in the format `actor1, actor2, type`, and `time` which is a vector of two values defining the first and last time point of the time window in which such dyads couldn't occur.
Consider the example on the `randomREH` data. For instance, we want to modify (shrink) the risk set according to two changes that apply on different time intervals:


```{r}
library(remify) # loading library
data(randomREH) # loading data
```


1. an event type `conflict` that was no more feasible since a specific time point until the end of the observation period.

```{r}
randomREH$omit_dyad[[1]]$time # start and stop time point defining the time window of interest
```
```{r}
randomREH$omit_dyad[[1]]$dyad # dyads to be removed from the time points defined by the interval in `time`
```

2. two actors `Michaela` and `Zackary` that couldn't interact with anybody else after a specific time point until the last observed time point.


```{r}
randomREH$omit_dyad[[2]]$time # start and stop time point defining the time window of interest
```
```{r}
randomREH$omit_dyad[[2]]$dyad # dyads to be removed from the time points defined by the interval in `time`
```


The object `dyad` will give instructions such that the function will remove from the risk set at the indicated time windows all the events where: (1) type is `conflict`, (2) `Michaela` and ``Zackary` are senders or receivers.

The `<NA>` values mean that all the actors/types are considered in that field. Indeed, in the first change where we needed to remove all the events where `conflict` was the type, we did it by leaving both `actor1` and `actor2` unspecified `<NA>`. 
Therefore, every time one field among (`actor1`,`actor2`,`type`) is left undefined, the omission from the risk set applies to all the possible values of that field.

------

## The processed risk set

- after processing the relational event history, also the input <i>omit_dyad</i> is processed and has a different shape
- plot a figure with the processed dynamic risk set, point out the structure of the output.