---
title: "The processing function <tt>reh()</tt>"
author: "Giuseppe Arena (g.arena@tilburguniversity.edu)"
package: remify
date: ""
output: rmarkdown::html_document
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{The processing function}
  %\VignetteEncoding{UTF-8}
---

<i>This vignette explains aim, inputs, outputs, attributes and methods of the function <tt>remify::reh()</tt>.</i>

## Aim of the function
The objective of <tt>remify::reh()</tt> is the processing of raw relational event data provided by the user along with other inputs that characterize them (actors' names, event types' names, starting time point of the event sequence, set of interactions to be excluded from the risk set at specific time points, etc.).
The internal routines will transform the structure of the input event sequence into a new one where actors and event types will have assigned unique (numerical) IDs. Furthermore, the function will provide other objects that will be required by all of the packages in [<tt>remverse</tt>](https://github.com/TilburgNetworkGroup/remverse).

As example, the `randomREH` data from the same package will be used (documentation available via `?randomREH`).

```{r}
library(remify) # loading library
data(randomREH) # loading data
names(randomREH) # objects inside the list 'randomREH'
```


<i>(Click on a tab pill below to show its content)</i>


# {.tabset .tabset-fade .tabset-pills}


## Input

<b>Input</b> arguments that can be supplied to `reh()` are: `edgelist`, `actors`, `types`, `directed`, `ordinal`, `origin`, `omit_dyad` and `model`. 

------

### <b><tt>edgelist</tt></b>

The edgelist must be a `data.frame` with column names `[time,actor1,actor2,type,weight]` (<i>Note</i>: it is not necessary to supply a column for `type` or `weight` but if they are included in the input edgelist, columns must be named `type` and `weight`, whereas it is compulsory to supply `[time,actor1,actor2]` and use such names for the columns).

```{r}
head(randomREH$edgelist)
```  
------

### <b><tt>actors</tt></b>

It is the vector of actor names (if left unspecified, names will be taken from the input `edgelist`). Their data type can be either `numeric` or `character`. In the `randomREH` data, a vector of actor names is provided.

```{r}
randomREH$actors
``` 
------

### <b><tt>types</tt></b>

It is the vector of type names (if left unspecified, names will be taken from the input `edgelist`). The data type can be either `numeric` or `character`. In the `randomREH` data a vector of types is provided.

```{r}
randomREH$types
```
------

### <b><tt>directed</tt></b>

It is a logical `TRUE`/`FALSE` value, indicating whether events are directed (`TRUE`) or not (`FALSE`). If `FALSE`, dyads will be sorted according to their names by following an alphanumerical order (e.g. `[actor1,actor2] = [Colton,Alexander]` will become `[actor1,actor2] = [Alexander,Colton]`).

------

### <b><tt>ordinal</tt></b>
It is a logical `TRUE`/`FALSE` value, indicating whether only the order of events matters in the model (when `TRUE`) or also the waiting times between event must be taken into account (when `FALSE`).

------

### <b><tt>origin</tt></b>
If the initial time point $t_0$ is known it can be specified by the argument `origin` and it must have the same class of the `time` column in the input `edgelist`. In the case such field is left unspecified (`NULL`), it is set by default to one day/second/time unit earlier than $t_1$ (time of the first observed event), for instance, when time is measured until seconds then $t_0 = t_1 - 1sec$ , when time is measured until minutes then $t_0 = t_1 - 1min$ and so forth. In the `randomREH` data a $t_0$ is provided.

```{r}
randomREH$origin
``` 

------

### <b><tt>omit_dyad</tt></b>
This argument is useful when certain dyads must be removed from the risk set in specific time windows (e.g. an actor drops out of the network, specific groups of actors cannot interact anymore starting from some time point). Therefore, the processing of such information makes the risk set suit better to the real data.
`omit_dyad` consists of a list of lists, and each list must have two objects: a `data.frame` called `dyad`, which specifies the dyads to be removed from the risk set, and `time` which is a vector of two values defining the first and last time point of the time window in which such dyads couldn't occur.
Consider the example on the `randomREH` data. For instance, we want to modify (shrink) the risk set according to two changes that apply on different time intervals:

1. an event type `conflict` that was no more feasible since a specific time point until the end of the observation period.

```{r}
randomREH$omit_dyad[[1]]$time # start and stop time point defining the time window of interest
```
```{r}
randomREH$omit_dyad[[1]]$dyad # dyads to be removed from the time points defined by the interval in `time`
```

2. two actors `Michaela` and `Zackary` that couldn't interact with anybody else after a specific time point until the last observed time point.


```{r}
randomREH$omit_dyad[[2]]$time # start and stop time point defining the time window of interest
```
```{r}
randomREH$omit_dyad[[2]]$dyad # dyads to be removed from the time points defined by the interval in `time`
```

The object `dyad` will give instructions such that the function will remove from the risk set at the indicated time windows all the events where: (1) type is `conflict`, (2) `Michaela` and ``Zackary` are senders or receivers.

The `<NA>` values mean that all the actors/types are considered in that field. Indeed, in the first change where we needed to remove all the events where `conflict` was the type, we did it by leaving both `actor1` and `actor2` unspecified `<NA>`. 
Therefore, every time one field among (`actor1`,`actor2`,`type`) is left undefined, the omission from the risk set applies to all the possible values of that field.

------

### <b><tt>model</tt></b>
Whether the model of interest is tie-oriented or actor-oriented, the argument `model` can be filled with either `"tie"` or `"actor"`.In the case of an actor-oriented model with changing risk set, the output will consist in two risk sets: senders' and dyads' risk sets. If no dynamic risk set is defined (`omit_dyad = NULL`), the argument `model` won't affect the output object.

------

### Running the example
```{r}
edgelist_reh <- reh(edgelist = randomREH$edgelist,
                    actors = randomREH$actors,
                    types = randomREH$types, 
                    directed = TRUE, # events are directed
                    ordinal = FALSE, # REM with waiting times
                    origin = randomREH$origin,
                    omit_dyad = randomREH$omit_dyad,
                    model = "tie")
```
## Output

The <b>output</b> of `reh()` is an S3 object of class `reh` and contains the following elements:

```{r}
names(edgelist_reh)
```

------

### <b><tt>M</tt></b>
`M` is the number of observed relational events.

```{r}
edgelist_reh$M
```

------

### <b><tt>N</tt></b>
`N` is the total number of actors that could interact in the network.

```{r}
edgelist_reh$N
```

------

### <b><tt>C</tt></b>
`C` is the number of event types (also referred as the sentiment of the event) that could be observed in the network.

```{r}
edgelist_reh$C
```

------

### <b><tt>D</tt></b>
`D` is the number of possible dyads throughout the network considering also the event types. Therefore:

  * if the network is <i>directed</i>, then $D = N(N-1)C$;
  * if the network is <i>undirected</i>, then $D = (N(N-1)/2)C$.

In other terms, it represents the largest observable size of the risk set.

```{r}
edgelist_reh$D
```

------

### <b><tt>IntereventTime</tt></b>
`intereventTime` is a numeric vector of waiting times between two subsequent events, that is:
$$\begin{bmatrix} t_1 - t_0 \\ t_2 - t_1 \\ \cdots \\ t_M - t_{M-1} \end{bmatrix}$$

```{r}
head(edgelist_reh$intereventTime)
```

------

### <b><tt>edgelist</tt></b>
`edgelist` is a `data.matrix` and consists of the converted input edgelist, with columns `[time,dyad,weight]` where the inputs `actor1`, `actor2` and `type` are converted into a `dyad` ID with values ranging in  $\left\lbrace 0,\ldots,D-1 \right\rbrace$. If `weight` is not supplied as input, then its corresponding column in the output edgelist will be a vector of $1$'s.

```{r}
head(edgelist_reh$edgelist)
```

------

### <b><tt>omit_dyad</tt></b>

If `omit_dyad` is supplied to the processing function, then the `reh` output object will contain the processed list under the same name. In the case of tie-oriented modeling, the list consists of two objects: a vector named `time` and a matrix named `riskset`.

- `riskset` is a 1/0's matrix where all the possible risk set modifications are described by row, and the columns identify the dyads ($D$ columns). The number of rows depends on the number of risk set modifications occurring in the event sequence, thus it remains variable.

- `time` is a vector of row indices that for each time point indicates which modification of the risk set (row index in the matrix `riskset`) is observed.

```{r}
edgelist_reh$omit_dyad$riskset[,1:10] # printing out the risk set modifications of only the first 10 columns (dyads). A total number of 2 modifications of the risk set are observed (by row)
```

The processed object `omit_dyad` (inside any `reh` object) will be required by other packages in [<tt>remverse</tt>](https://github.com/TilburgNetworkGroup/remverse). Given that such packages have function written in C++, the row indices in the vector start at 0 (indicating row 1 in the matrix above) and they assume value -1 when no risk set alteration is observed.

```{r}
edgelist_reh$omit_dyad$time[1:10] # printing out the first 10 time points. We can see that in none of the 10 time points any modification takes place (-1)
```

In the case of actor-oriented modeling with changing risk set, the `omit_dyad` output list consists of three objects: a vector named `time` (same vector as explained above) and two risk set matrices (`senderRiskset` and `riskset`), one for the sender and one for the dyads. Both risk set matrices follow the same structure as the matrix `riskset` in the tie-oriented modeling.
Whenever `omit_dyad` is not supplied to `reh()` then its output in the `reh` object will be an empty list.

## Attributes


The <b>attributes</b> of an `reh` object are:

```{r}
names(attributes(edgelist_reh))
```

------

### <b><tt>names</tt></b>
`names` is the vector of the names of the output objects which are discussed already in section 'Output'.

```{r}
attr(edgelist_reh, "names")
```

------

### <b><tt>class</tt></b>
The `class` attribute returns the class name of the object, that is `reh`.

```{r}
attr(edgelist_reh, "class")
```

------

### <b><tt>with_type</tt></b>
`with_type` is a logical `TRUE`/`FALSE` value indicating whether more than one event type is observed in the network (`TRUE`) or not (`FALSE`).

```{r}
attr(edgelist_reh, "with_type")
```

------

### <b><tt>weighted</tt></b>
`weighted` is a logical `TRUE`/`FALSE` value indicating whether relational events have weights (`TRUE`) or not (`FALSE`).

```{r}
attr(edgelist_reh, "weighted")
```

------

### <b><tt>directed</tt></b>
`directed` is a logical `TRUE`/`FALSE` value indicating whether we know (`TRUE`) for each event whom originated the action (sender) and whom was the target (receiver) of it, or we don't know (`FALSE`) the source and the target of an event but only the actors that were involved in it.

```{r}
attr(edgelist_reh, "directed")
```

------

### <b><tt>ordinal</tt></b>
`ordinal` is a logical `TRUE`/`FALSE` value indicating whether in the model we want to consider the waiting times between events (`FALSE`) or not and consider only the order of the relational events (`TRUE`).

```{r}
attr(edgelist_reh, "ordinal")
```

------

### <b><tt>model</tt></b>
`model` describes whether the output of `reh` is suitable for the actor-oriented model (`model = "actor"`) or for the tie-oriented model (`model = "tie"`).

```{r}
attr(edgelist_reh, "model")
```

------

### <b><tt>riskset</tt></b>
`riskset` describes the type of risk set that resulted from the processing of the data. If `omit_dyad` is provided, this means that the risk set is going to change for certain time windows and then `riskset = "dynamic"`. Otherwise, when `omit_dyad = NULL`, the risk set is assumed to be the largest observable one (of dimensions $D$) and it maintains the same structure throughout the network (`riskset = "static"`).  

```{r}
attr(edgelist_reh, "riskset")
```

------

### <b><tt>dictionary</tt></b>
`dictionary` is a list of two `data.frame`'s: `actors` and `types`.

  - `actors` has two columns: the first with actor names (`actorName`) sorted according to their alphanumerical order, the second with their corresponding ID's (`actorID`), ranging in $\left\lbrace 0,\ldots,N-1 \right\rbrace$;
  - `types` has two columns: the first with type names (`typeName`) sorted according to their alphanumerical order, the second with their corresponding ID's (`typeID`), ranging in $\left\lbrace 0,\ldots,C-1 \right\rbrace$; 

```{r}
attr(edgelist_reh, "dictionary")
```

------

### <b><tt>time</tt></b>
`time` is a list of three objects: `class`, `value` and `origin`.

  - `class` returns the class of the column `time` provided in the input `edgelist`;
  - `value` is a `data.frame` of size $[M \times 2]$ where the first column is the `time` variable supplied in the input `edgelist` and the second column is the `intereventTime` (already discussed in section 'Output');
  - `origin` is the input argument already discussed in section 'Input'.

```{r}
str(attr(edgelist_reh, "time")) # printing out only the str() of the attribute since the data.frame `value` is large
```



## Methods

The available <b>methods</b> for an `reh` object are: `summary`, `dim`, `getDynamicRiskset`, `actorName`, `typeName`, `actorID`, and `typeID`.

------

### <b><tt>summary</tt></b>
`summary(reh)` prints out a brief summary of the relational network data.

```{r}
summary(edgelist_reh)
```

------

### <b><tt>dim</tt></b>
`dim(reh)` returns some useful dimensions characterizing the network, such as: number of events, number of actors, number of event types, number of dyads. 

```{r}
dim(edgelist_reh)
```

------

### <b><tt>getDynamicRiskset</tt></b>

If `omit_dyad` is supplied to the processing function, `getDynamicRiskset(reh)` returns the processed dynamic risk set matrix (or the two dynamic risk sets if actor-oriented modeling) that are explained in 'Output' under the section about `omit_dyad`.

```{r}
getDynamicRiskset(edgelist_reh)$riskset[,1:10] # printing out the risk set modifications of only the first 10 columns (dyads). A total number of 2 modifications of the risk set are observed (by row)
```
------

### <b><tt>actorName</tt></b>
`actorName(reh,actorID)`: by supplying one or more `actorID`'s it returns the corresponding (input) names.

```{r}
actorName(reh = edgelist_reh, actorID = c(0,12,19))
```

------

### <b><tt>typeName</tt></b>
`typeName(reh,typeID)`: by supplying one or more `typeID`'s it returns the corresponding (input) names.

```{r}
typeName(reh = edgelist_reh, typeID = c(0,2))
```

------

### <b><tt>actorID</tt></b>
`actorID(reh,actorName)`: by supplying one or more `actorName`'s it returns the corresponding ID's.

```{r}
actorID(reh = edgelist_reh, actorName = c("Michaela","Alexander","Lexy"))
```

------

### <b><tt>typeID</tt></b>
`typeID(reh,typeName)`: by supplying one or more `typeName`'s it returns the corresponding ID's.

```{r}
typeID(reh = edgelist_reh, typeName = "cooperation")
```

